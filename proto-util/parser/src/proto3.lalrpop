use crate::{ast, lexer};

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = lexer::LexicalError<'input>;

    enum lexer::Token<'input> {
        SingleLineComment => lexer::Token::SingleLineComment(<&'input str>),
        MultiLineComment => lexer::Token::MultiLineComment(<&'input str>),

        Eq => lexer::Token::Eq,
        Colon => lexer::Token::Colon,
        Semicolon => lexer::Token::Semicolon,
        Comma => lexer::Token::Comma,
        Period => lexer::Token::Period,

        OpenPth => lexer::Token::OpenPth,
        ClosePth => lexer::Token::ClosePth,
        OpenBracket => lexer::Token::OpenBracket,
        CloseBracket => lexer::Token::CloseBracket,
        OpenBrace => lexer::Token::OpenBrace,
        CloseBrace => lexer::Token::CloseBrace,
        OpenAngle => lexer::Token::OpenAngle,
        CloseAngle => lexer::Token::CloseAngle,

        Boolean => lexer::Token::Boolean(<bool>),
        Integer => lexer::Token::Integer(<i64>),
        String => lexer::Token::String(<&'input str>),

        Ident => lexer::Token::Ident(<&'input str>),

        "to" => lexer::Token::To,
        "max" => lexer::Token::Max,
        "syntax" => lexer::Token::Syntax,
        "option" => lexer::Token::Option,
        "package" => lexer::Token::Package,
        "import" => lexer::Token::Import,
        "message" => lexer::Token::Message,
        "extend" => lexer::Token::Extend,
        "enum" => lexer::Token::Enum,
        "reserved" => lexer::Token::Reserved,
        "extensions" => lexer::Token::Extensions,
        "optional" => lexer::Token::Optional,
        "required" => lexer::Token::Required,
        "repeated" => lexer::Token::Repeated,
        "map" => lexer::Token::Map,
    }
}


// Protocol Buffers 2 and 3 keywords.

#[inline]
Keyword: &'input str = { FieldTypeKeyword, NonFieldTypeKeyword };

FieldTypeKeyword: &'input str = {
    "to" => "to",
    "max" => "max",
    "syntax" => "syntax",
    "package" => "package",
    "import" => "import",
};

NonFieldTypeKeyword: &'input str = {
    "option" => "option",
    "message" => "message",
    "extend" => "extend",
    "enum" => "enum",
    "reserved" => "reserved",
    "extensions" => "extensions",
    "optional" => "optional",
    "required" => "required",
    "repeated" => "repeated",
    "map" => "map",
};

#[inline]
IdentLike = { Keyword, Ident };


// [.]optional.package

#[inline]
Path = { SafePath, UnsafePath }

#[inline]
LPath = { SafeLPath, UnsafePath };

// Use-case         Unsafe  Safe
// ident.ident               ++
// keyword.ident      ++
UnsafePath: &'input str = <l:@L> Keyword  (Period IdentLike)* <r:@R> => &input[l..r];
  SafePath: &'input str = <l:@L> Ident    (Period IdentLike)* <r:@R> => &input[l..r];

//                  Unsafe  Safe
//    ident.ident            ++
// .  ident.ident            ++
//   keyword.ident    ++
// . keyword.ident           ++
#[inline] UnsafeLPath : &'input str = UnsafePath;
            SafeLPath : &'input str = {
    <l:@L> Period   UnsafePath  <r:@R> => &input[l..r],
    <l:@L> Period?  SafePath    <r:@R> => &input[l..r],
};

Range: ast::Range = {
    Integer                             => ast::Range::from(<>),
    <start:Integer> "to" <end:Integer>  => ast::Range::from(start..end),
    <start:Integer> "to" <end:"max">    => ast::Range::from((start, ())),
};

CommaList<T>: Vec<T> = <first:T> <mut rest:(Comma <T>)*> => { rest.insert(0, first); rest };
TrailingCommaList<T>: Vec<T> = <first:T> <mut rest:(Comma <T>)*> Comma? => { rest.insert(0, first); rest };

ExpressionList<T>: Vec<T> = <v:(<T> Semicolon?)*> => <>;

Block<K, I, E> = K <I> OpenBrace <ExpressionList<E>> CloseBrace;

// proto

pub GlobalScope: ast::GlobalScope<'input> = ExpressionList<Expr>;

pub Expr: ast::Expr<'input> = {
    Comment => ast::Expr::Comment(<>),

    // syntax = "proto3";
    "syntax" Eq <String> Semicolon => ast::Expr::Syntax(<>),

    // package aa.AA;
    "package" <Path> Semicolon => ast::Expr::Package(<>),

    // import "xxx/yyy/zzz.proto";
    "import" <String> Semicolon => ast::Expr::Import(<>),

    // option java_package = "xx.yy.zz";
    OptionLine => ast::Expr::Option(<>),

    // message [ident] { ... }
    Message => ast::Expr::Message(<>),

    // extend [ident] { ... }
    Extend => ast::Expr::Extend(<>),

    // enum [ident] { ... }
    Enum => ast::Expr::Enum(<>),
};


// comment

Comment: ast::Comment<'input> = {
    SingleLineComment => ast::Comment::single_line(<>),
    MultiLineComment => ast::Comment::multi_line(<>),
};


// option

Option: ast::Option<'input> = <key:OptionKey> Eq <value:MapValue> => ast::Option { key, value };

OptionKey: &'input str = {
    <l:@L> OpenPth LPath ClosePth <r:@R> => &input[l..r],
    Path,
}

JSONLikeMap: ast::JSONLikeMap<'input>
    = OpenBrace <TrailingCommaList<(<Ident> Colon <MapValue>)>> CloseBrace
    => ast::JSONLikeMap::<'input>::from_iter(<>);

MapValue: ast::MapValue<'input> = {
    Boolean => ast::MapValue::Boolean(<>),
    Integer => ast::MapValue::Integer(<>),
    Ident => ast::MapValue::Ident(<>),
    String => ast::MapValue::String(<>),
    JSONLikeMap => ast::MapValue::Map(<>),
};

OptionLine = "option" <Option> Semicolon;
EntryOptionList: Vec<ast::Option<'input>> = <(OpenBracket <CommaList<Option>> CloseBracket)?> => <>.unwrap_or(vec![]);


// message [ident] { ... }

pub Message: ast::Message<'input> = Block<"message", IdentLike, MessageEntry> => ast::Message { ident: <>.0, entries: <>.1 };

pub MessageEntry: ast::MessageEntry<'input> = {
    Comment => ast::MessageEntry::Comment(<>),
    OptionLine => ast::MessageEntry::Option(<>),
    Message => ast::MessageEntry::Message(<>),
    Extend => ast::MessageEntry::Extend(<>),
    Enum => ast::MessageEntry::Enum(<>),
    Field => ast::MessageEntry::Field(<>),
    ReservedIndices => ast::MessageEntry::ReservedIndices(<>),
    ReservedIdents => ast::MessageEntry::ReservedIdents(<>),
    Extensions => ast::MessageEntry::Extensions(<>),
};


// [optional | repeated] [type] [ident] = [index];
pub Field: ast::Field<'input> = {
    <modifier:FieldModifier>

    <r#type:UnsafeFieldType>    <ident:IdentLike> Eq <index:Integer> <options:EntryOptionList> Semicolon
        => ast::Field { modifier, r#type, ident, index, options },

    <r#type:SafeFieldType>      <ident:IdentLike> Eq <index:Integer> <options:EntryOptionList> Semicolon
        => ast::Field { modifier: ast::FieldModifier::None, r#type, ident, index, options },
};

FieldModifier: ast::FieldModifier = {
    "optional" => ast::FieldModifier::Optional,
    "required" => ast::FieldModifier::Required,
    "repeated" => ast::FieldModifier::Repeated,
};


//           Use-case              SafeFieldType  UnsafeFieldType
// [mod]    path            ...         N/A             +
// [mod]   .path            ...         N/A             +
// [mod]    keyword.path    ...         N/A             +
// [mod]   .keyword.path    ...         N/A             +
//          path            ...          +             N/A
//         .path            ...          +             N/A
//          keyword.path    ...                        N/A
//         .keyword.path    ...          +             N/A
#[inline] SafeFieldType   : &'input str = { MapFieldType, SafeLPath, FieldTypeKeyword   };
#[inline] UnsafeFieldType : &'input str = { MapFieldType, LPath                         };

MapFieldType: &'input str = <l:@L> "map" OpenAngle Ident Comma IdentLike CloseAngle <r:@R> => &input[l..r];


// extensions 1000 to max;

Extensions: Vec<ast::Range> = "extensions" <CommaList<Range>> Semicolon;


// reserved 2, 3, 4 to 6;

ReservedIndices: Vec<ast::Range> = "reserved" <CommaList<Range>> Semicolon;


// reserved "xd", "xdd";

ReservedIdents: Vec<&'input str> = "reserved" <CommaList<String>> Semicolon;


// extend [ident] { ... }

pub Extend: ast::Extend<'input> = Block<"extend", LPath, ExtendEntry> => ast::Extend { r#type: <>.0, entries: <>.1 };

pub ExtendEntry: ast::ExtendEntry<'input> = {
    Comment => ast::ExtendEntry::Comment(<>),
    Field => ast::ExtendEntry::Field(<>),
};

// enum [ident] { ... }

pub Enum: ast::Enum<'input> = Block<"enum", IdentLike, EnumEntry> => ast::Enum { ident: <>.0, entries: <>.1 };

pub EnumEntry: ast::EnumEntry<'input> = {
    Comment => ast::EnumEntry::Comment(<>),
    OptionLine => ast::EnumEntry::Option(<>),
    <ident:IdentLike> Eq <value:Integer> <options:EntryOptionList> Semicolon => ast::EnumEntry::Pair{ ident, value, options },
};