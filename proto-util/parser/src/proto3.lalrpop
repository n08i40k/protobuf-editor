use crate::{ast, lexer};

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = lexer::LexicalError<'input>;

    enum lexer::Token<'input> {
        SingleLineComment => lexer::Token::SingleLineComment(<&'input str>),
        MultiLineComment => lexer::Token::MultiLineComment(<&'input str>),

        Eq => lexer::Token::Eq,
        Colon => lexer::Token::Colon,
        Semicolon => lexer::Token::Semicolon,
        Comma => lexer::Token::Comma,
        Period => lexer::Token::Period,

        OpenPth => lexer::Token::OpenPth,
        ClosePth => lexer::Token::ClosePth,
        OpenBracket => lexer::Token::OpenBracket,
        CloseBracket => lexer::Token::CloseBracket,
        OpenBrace => lexer::Token::OpenBrace,
        CloseBrace => lexer::Token::CloseBrace,
        OpenAngle => lexer::Token::OpenAngle,
        CloseAngle => lexer::Token::CloseAngle,

        Boolean => lexer::Token::Boolean(<bool>),
        Integer => lexer::Token::Integer(<i64>),
        String => lexer::Token::String(<&'input str>),

        Ident => lexer::Token::Ident(<&'input str>),

        "to" => lexer::Token::To,
        "max" => lexer::Token::Max,
        "syntax" => lexer::Token::Syntax,
        "option" => lexer::Token::Option,
        "package" => lexer::Token::Package,
        "import" => lexer::Token::Import,
        "message" => lexer::Token::Message,
        "extend" => lexer::Token::Extend,
        "enum" => lexer::Token::Enum,
        "reserved" => lexer::Token::Reserved,
        "extensions" => lexer::Token::Extensions,
        "optional" => lexer::Token::Optional,
        "required" => lexer::Token::Required,
        "repeated" => lexer::Token::Repeated,
        "map" => lexer::Token::Map,
    }
}


// basic

IdentLike: &'input str = {
    Ident,
    "to" => "to",
    "max" => "max",
    "syntax" => "syntax",
    "option" => "option",
    "package" => "package",
    "import" => "import",
    "message" => "message",
    "extend" => "extend",
    "enum" => "enum",
    "reserved" => "reserved",
    "extensions" => "extensions",
    "optional" => "optional",
    "required" => "required",
    "repeated" => "repeated",
    "map" => "map",
};

Range: ast::Range = {
    Integer                             => ast::Range::from(<>),
    <start:Integer> "to" <end:Integer>  => ast::Range::from(start..end),
    <start:Integer> "to" <end:"max">    => ast::Range::from((start, ())),
};

Package: &'input str = <l:@L> IdentLike (Period IdentLike)* <r:@R> => &input[l..r];

CommaList<T>: Vec<T> = <first:T> <mut rest:(Comma <T>)*> => { rest.insert(0, first); rest };
TrailingCommaList<T>: Vec<T> = <first:T> <mut rest:(Comma <T>)*> Comma? => { rest.insert(0, first); rest };

ExpressionList<T>: Vec<T> = <v:(<T> Semicolon?)*> => <>;

Block<I, B> = I <IdentLike> OpenBrace <B> CloseBrace;

// proto

pub GlobalScope: ast::GlobalScope<'input> = ExpressionList<Expr>;

pub Expr: ast::Expr<'input> = {
    Comment => ast::Expr::Comment(<>),

    // syntax = "proto3";
    "syntax" Eq <String> Semicolon => ast::Expr::Syntax(<>),

    // package aa.AA;
    "package" <Package> Semicolon => ast::Expr::Package(<>),

    // import "xxx/yyy/zzz.proto";
    "import" <String> Semicolon => ast::Expr::Import(<>),

    // option java_package = "xx.yy.zz";
    OptionLine => ast::Expr::Option(<>),

    // message [ident] { ... }
    Message => ast::Expr::Message(<>),

    // extend [ident] { ... }
    Extend => ast::Expr::Extend(<>),

    // enum [ident] { ... }
    Enum => ast::Expr::Enum(<>),
};


// comment

Comment: ast::Comment<'input> = {
    SingleLineComment => ast::Comment::single_line(<>),
    MultiLineComment => ast::Comment::multi_line(<>),
};


// option

Option: ast::Option<'input> = <key:OptionKey> Eq <value:MapValue> => ast::Option { key, value };

OptionKey: &'input str = {
    <l:@L> OpenPth Period? Package ClosePth <r:@R> => &input[l..r],
    Package,
}

JSONLikeMap: ast::JSONLikeMap<'input>
    = OpenBrace <TrailingCommaList<(<Ident> Colon <MapValue>)>> CloseBrace
    => ast::JSONLikeMap::<'input>::from_iter(<>);

MapValue: ast::MapValue<'input> = {
    Boolean => ast::MapValue::Boolean(<>),
    Integer => ast::MapValue::Integer(<>),
    Ident => ast::MapValue::Ident(<>),
    String => ast::MapValue::String(<>),
    JSONLikeMap => ast::MapValue::Map(<>),
};

OptionLine = "option" <Option> Semicolon;
EntryOptionList: Vec<ast::Option<'input>> = <(OpenBracket <CommaList<Option>> CloseBracket)?> => <>.unwrap_or(vec![]);


// message [ident] { ... }

pub Message: ast::Message<'input> = Block<"message", MessageEntryList> => ast::Message { ident: <>.0, entries: <>.1 };

MessageEntryList: Vec<ast::MessageEntry<'input>> = ExpressionList<MessageEntry>;
pub MessageEntry: ast::MessageEntry<'input> = {
    Comment => ast::MessageEntry::Comment(<>),
    OptionLine => ast::MessageEntry::Option(<>),
    Message => ast::MessageEntry::Message(<>),
    Extend => ast::MessageEntry::Extend(<>),
    Enum => ast::MessageEntry::Enum(<>),
    Field => ast::MessageEntry::Field(<>),
    ReservedIndices => ast::MessageEntry::ReservedIndices(<>),
    ReservedIdents => ast::MessageEntry::ReservedIdents(<>),
    Extensions => ast::MessageEntry::Extensions(<>),
};


// [optional | repeated] [type] [ident] = [index];

pub Field: ast::Field<'input> = {
    <modifier:FieldModifier>
    <r#type:FieldType>
    <ident:IdentLike>
    Eq
    <index:Integer>
    <options:EntryOptionList>
    Semicolon
    => ast::Field { modifier, r#type, ident, index, options }
};

FieldModifier: ast::FieldModifier = {
    => ast::FieldModifier::None,
    "optional" => ast::FieldModifier::Optional,
    "required" => ast::FieldModifier::Required,
    "repeated" => ast::FieldModifier::Repeated,
};

FieldType = {
    <l:@L> "map" OpenAngle IdentLike Comma IdentLike CloseAngle <r:@R> => &input[l..r],
    Ident,
    "to" => "to",
    "max" => "max",
    "syntax" => "syntax",
    "package" => "package",
    "import" => "import",
};


// extensions 1000 to max;

Extensions: Vec<ast::Range> = "extensions" <CommaList<Range>> Semicolon;


// reserved 2, 3, 4 to 6;

ReservedIndices: Vec<ast::Range> = "reserved" <CommaList<Range>> Semicolon;


// reserved "xd", "xdd";

ReservedIdents: Vec<&'input str> = "reserved" <CommaList<String>> Semicolon;


// extend [ident] { ... }

pub Extend: ast::Extend<'input> = "extend" <r#type:Package> OpenBrace <entries:ExtendEntryList> CloseBrace => ast::Extend { r#type, entries };

ExtendEntryList: Vec<ast::ExtendEntry<'input>> = ExpressionList<ExtendEntry>;
pub ExtendEntry: ast::ExtendEntry<'input> = {
    Comment => ast::ExtendEntry::Comment(<>),
    Field => ast::ExtendEntry::Field(<>),
};

// enum [ident] { ... }

pub Enum: ast::Enum<'input> = Block<"enum", EnumEntries> => ast::Enum { ident: <>.0, entries: <>.1 };

EnumEntries: Vec<ast::EnumEntry<'input>> = ExpressionList<EnumEntry>;
pub EnumEntry: ast::EnumEntry<'input> = {
    Comment => ast::EnumEntry::Comment(<>),
    OptionLine => ast::EnumEntry::Option(<>),
    <ident:IdentLike> Eq <value:Integer> <options:EntryOptionList> Semicolon => ast::EnumEntry::Pair{ ident, value, options },
};